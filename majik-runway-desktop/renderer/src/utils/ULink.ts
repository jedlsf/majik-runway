import cryptoJS from 'crypto-js';

export class ULink {
    private type: string;
    private stx: string;
    private validity: number; // validity in seconds
    private user: {
        auth: string | null;
        hash: string | null; // the hashed version of the auth string
    };

    constructor(type: string, stx: string, validity: number, auth: string) {
        this.type = type;
        this.stx = stx || secureTimecode();
        this.validity = validity || 0;
        this.user = {
            auth,
            hash: hashAuth(auth),
        };
    }

    isValid(): boolean {
        try {
            if (!this.stx || !this.validity) {
                return false;
            }

            if (this.validity === 0) {
                return true;
            } else {
                return !isSTXExpired(this.stx, this.validity);
            }

        } catch (error) {
            console.error('Error validating ULink:', error);
            return false;
        }

    }



}



/**
     * Generates a SHA-256 hash for a given string.
     * Validates that the input is a non-empty string.
     * @param {string} auth - The string to hash.
     * @returns {string} The hash of the string in hexadecimal format.
     * @throws {Error} If the input is not a valid non-empty string.
     */
export function hashAuth(auth: string): string {
    const hash = cryptoJS.SHA256(auth);
    const hashString = hash.toString(cryptoJS.enc.Hex);
    return hashString;

}

/**
 * Converts a Unix timestamp, Date object, ISO string, or null/undefined into a secure Base64 string.
 * Defaults to the current time if input is null or undefined.
 *
 * @param {(number | Date | string | null | undefined)} input - The time input.
 * @returns {string} A secure Base64 encoded string generated from the timestamp.
 * @throws {Error} Throws an error if the input is not a valid time format.
 */
export function secureTimecode(input?: number | Date | string | null | undefined): string {
    const unixTimestamp = (() => {
        if (input === null || input === undefined) return Math.floor(Date.now() / 1000);
        if (typeof input === 'number') return input;
        if (input instanceof Date) return Math.floor(input.getTime() / 1000);
        if (typeof input === 'string') return Math.floor(new Date(input).getTime() / 1000);
        throw new Error('Invalid input type. Must be Unix timestamp, Date object, or ISO string.');
    })();

    const unixArray = Array.from(String(unixTimestamp), Number);
    const reversedArray = [...unixArray].reverse();
    const invertedArray: number[] = [];

    for (let i = 0; i < unixArray.length; i++) {
        invertedArray.push(unixArray[i], reversedArray[i]);
    }

    return btoa(String.fromCharCode(...invertedArray));
}

/**
 * Decodes a Base64 string generated by secureTimecode back into a Unix timestamp.
 *
 * @param {string} base64String - The Base64 string to decode.
 * @returns {number} The decoded Unix timestamp.
 * @throws {Error} Throws an error if validation fails (reversed array doesn't match original).
 */
export function decodeSecureTimecode(base64String: string): number {
    const decodedArray = Array.from(atob(base64String)).map(char => char.charCodeAt(0));

    const originalArray = decodedArray.filter((_, i) => i % 2 === 0);
    const reversedArray = decodedArray.filter((_, i) => i % 2 !== 0).reverse();

    if (originalArray.join('') !== reversedArray.join('')) {
        throw new Error('Validation failed: reversed array does not match the original array.');
    }

    return parseInt(originalArray.join(''), 10);
}

/**
 * Checks if a Unix timestamp has expired based on a specified duration in seconds.
 *
 * @param {number} durationInSeconds - The allowed duration in seconds for the timestamp.
 * @param {number} unixTimestamp - The Unix timestamp to check.
 * @returns {boolean} Returns true if the timestamp has expired, false otherwise.
 * @throws {Error} Throws an error if the unixTimestamp is not a valid Unix timestamp.
 */
export function isTimestampExpired(durationInSeconds: number, unixTimestamp: number): boolean {
    if (typeof unixTimestamp !== 'number' || isNaN(unixTimestamp)) {
        throw new Error('Invalid unixTimestamp: must be a number.');
    }
    const currentTime = Math.floor(Date.now() / 1000);
    return currentTime > unixTimestamp + durationInSeconds;
}

/**
 * Checks if a decoded Base64 timecode has expired based on a specified duration in seconds.
 *
 * @param {string} base64String - The Base64 encoded timecode.
 * @param {number} durationInSeconds - The allowed duration in seconds.
 * @returns {boolean} Returns true if the decoded Unix timestamp has expired, false otherwise.
 * @throws {Error} Throws an error if validation of the decoded timecode fails.
 */
export function isSTXExpired(base64String: string, durationInSeconds: number): boolean {
    const unixTimestamp = decodeSecureTimecode(base64String);
    return isTimestampExpired(durationInSeconds, unixTimestamp);
}



/**
 * Converts input to a string and reverses it.
 * If the input is a number, it is converted to a string.
 * If the input is an object (JSON), it is stringified.
 * If secure is true, it returns a Base64 encoded result.
 * @param {any} input - The input to reverse.
 * @param {boolean} secure - Whether to Base64 encode the result.
 * @returns {string} - The reversed string, possibly encoded.
 */
export function secureReverse(input: string | object | number, secure: boolean = true): string {
    let str: string;
    if (typeof input === 'number') {
        str = input.toString();
    } else if (typeof input === 'object') {
        str = JSON.stringify(input);
    } else {
        str = input;
    }


    let reversedString = str.split('').reverse().join('');

    if (secure) {
        reversedString = btoa(reversedString);
    }

    return reversedString;
}


/**
 * Decodes the reversed string based on the mode provided.
 * If secure is true, the reversed string is decoded from Base64 first.
 * @param {string} reversedString - The reversed string (possibly Base64 encoded).
 * @param {string|null} mode - The mode to decode ('json', 'number', or 'string').
 * @param {boolean} secure - Whether the input is Base64 encoded.
 * @returns {any} - The decoded result based on the mode.
 */
export function decodeReverse(reversedString: string, mode: string = "string", secure: boolean = true): string | object | number {
    // If secure is true, decode the reversed string from Base64
    if (secure) {
        reversedString = atob(reversedString);
    }

    const restoredString = reversedString.split('').reverse().join('');

    if (mode === 'json') {
        try {
            return JSON.parse(restoredString);
        } catch (error) {
            throw new Error(`Invalid JSON format. ${error}`);
        }
    } else if (mode === 'number') {
        const number = parseFloat(restoredString);
        if (!number) {
            throw new Error('Reversed string is not a valid number');
        }
        return number;
    } else {
        return restoredString; // Treat as string if mode is 'string' or null
    }
}
