import {
  deserializeMoney,
  MajikMoney,
  serializeMoney,
} from "@thezelijah/majik-money";
import { ExpenseType, Recurrence } from "../enums";
import {
  ExpenseID,
  PeriodYYYYMM,
  StartDateInput,
  YYYYMM,
} from "../types/types";
import { ExpenseJSON, ExpenseState, MonthlyAllocation } from "./types";
import {
  autogenerateID,
  monthsInPeriod,
  isValidYYYYMM,
  normalizeStartDate,
  offsetMonthsToYYYYMM,
} from "../utils";

/**
 * Represents a financial expense in MajikRunway.
 *
 * Supports one-time, recurring, and capital (depreciable) expenses.
 * Immutable: all modifications return a new Expense instance.
 */
export class Expense {
  /**
   * Private constructor. Use static factories to create expenses.
   * @param state The internal read-only state of the expense.
   */
  private constructor(private readonly state: Readonly<ExpenseState>) {
    this.validate();
  }

  /* ---------- Factories ---------- */

  /**
   * Creates a new Expense from a raw state object.
   * @param state ExpenseState object
   * @returns Expense instance
   */
  static create(state: ExpenseState): Expense {
    return new Expense(Expense.normalize(state));
  }

  /**
   * Quickly create a recurring operating expense.
   * @param id Optional ID, autogenerated if omitted
   * @param name Expense name
   * @param amount Amount in major currency units
   * @param currency Currency code (default "PHP")
   * @param recurrence Recurrence pattern (default Monthly)
   * @param period The timeline period
   * @param isTaxDeductible Whether expense is tax-deductible (default true)
   * @returns Expense instance
   */
  static recurring(
    id: ExpenseID = autogenerateID("mjkex"),
    name: string,
    amount: number,
    currency: string = "PHP",
    recurrence: Recurrence = Recurrence.Monthly,
    period: PeriodYYYYMM,
    isTaxDeductible?: boolean
  ): Expense {
    const majikAmount = MajikMoney.fromMajor(amount, currency);

    if (!period || !period?.startMonth || !period?.endMonth) {
      throw new Error("Recurring expense must define period");
    }

    if (monthsInPeriod(period.startMonth, period.endMonth) <= 0) {
      throw new Error("Invalid expense period");
    }

    const schedule = Expense.generateExpenseScheduleForPeriod(
      monthsInPeriod(period.startMonth, period.endMonth),
      majikAmount,
      recurrence,
      period.startMonth
    );

    return Expense.create({
      id,
      name,
      type: ExpenseType.Operating,
      amount: MajikMoney.fromMajor(amount, currency),
      recurrence,
      isTaxDeductible: isTaxDeductible ?? true,
      schedule,
    });
  }

  /**
   * Quickly create a one-time expense for a specific month.
   * @param id Optional ID, autogenerated if omitted
   * @param name Expense name
   * @param amount Amount in major currency units
   * @param currency Currency code (default "PHP")
   * @param month Month in YYYYMM format
   * @param isTaxDeductible Whether expense is tax-deductible (default true)
   * @returns Expense instance
   */
  static oneTime(
    id: ExpenseID = autogenerateID("mjkex"),
    name: string,
    amount: number,
    currency: string = "PHP",
    month: YYYYMM,
    isTaxDeductible?: boolean
  ): Expense {
    return Expense.create({
      id,
      name,
      type: ExpenseType.Operating,
      amount: MajikMoney.fromMajor(amount, currency),
      schedule: [{ month, amount: MajikMoney.fromMajor(amount, currency) }],
      isTaxDeductible: isTaxDeductible ?? true,
    });
  }

  /**
   * Quickly create a capital (depreciable) expense.
   * @param id Optional ID, autogenerated if omitted
   * @param name Expense name
   * @param amount Amount in major currency units
   * @param currency Currency code (default "PHP")
   * @param month Month in YYYYMM format
   * @param depreciationMonths Number of months to depreciate
   * @param residualValue Optional residual value after depreciation
   * @param isTaxDeductible Whether expense is tax-deductible (default true)
   * @returns Expense instance
   */
  static capital(
    id: ExpenseID = autogenerateID("mjkex"),
    name: string,
    amount: number,
    currency: string = "PHP",
    month: YYYYMM,
    depreciationMonths: number,
    residualValue?: number,
    isTaxDeductible?: boolean
  ): Expense {
    if (!isValidYYYYMM(month)) {
      throw new Error("Invalid capital expense month");
    }

    const majikAmount = MajikMoney.fromMajor(amount, currency);

    return Expense.create({
      id,
      name,
      type: ExpenseType.Capital,
      amount: majikAmount,
      isTaxDeductible: isTaxDeductible ?? true,

      //  single purchase month = cash out + depreciation anchor
      schedule: [
        {
          month,
          amount: majikAmount,
        },
      ],

      capitalMeta: {
        depreciationMonths,
        residualValue: residualValue
          ? MajikMoney.fromMajor(residualValue, currency)
          : undefined,
      },
    });
  }

  /**
   * Generates a monthly allocation array for recurring expenses.
   * Spreads the expense correctly according to recurrence.
   *
   * @param months - Number of months to generate
   * @param amount - Base amount as MajikMoney
   * @param recurrence - Recurrence type
   * @param startDate - Date | ISO | YYYYMM (defaults to current month)
   * @returns MonthlyAllocation[]
   */
  static generateExpenseScheduleForPeriod(
    months: number,
    amount: MajikMoney,
    recurrence: Recurrence,
    startDate?: StartDateInput
  ): MonthlyAllocation[] {
    if (!Number.isInteger(months) || months <= 0) {
      throw new Error("Months must be a positive integer");
    }

    const startDateObj = normalizeStartDate(startDate); // returns Date
    const allocations: MonthlyAllocation[] = [];

    // Determine monthly amount
    let monthlyAmount = amount;
    if (recurrence === Recurrence.Quarterly) monthlyAmount = amount.divide(3);
    else if (recurrence === Recurrence.Yearly)
      monthlyAmount = amount.divide(12);

    // Spread evenly across all months
    for (let i = 0; i < months; i++) {
      const currentYYYYMM = offsetMonthsToYYYYMM(startDateObj, i);
      allocations.push({ month: currentYYYYMM, amount: monthlyAmount });
    }

    return allocations;
  }

  /* ---------- Accessors ---------- */

  /** Unique identifier for the expense */
  get id(): ExpenseID {
    return this.state.id;
  }

  /** Name of the expense */
  get name(): string {
    return this.state.name;
  }

  /** Expense type (Operating or Capital) */
  get type(): ExpenseType {
    return this.state.type;
  }

  /** Expense category (One Time, Recurring, or Capital) */
  get category(): string {
    if (this.isCapital) return "Capital";
    if (this.isOneTime) return "One-Time";
    if (this.isRecurring) return "Recurring";
    return "Unknown Category";
  }

  get recurrence(): Recurrence | null {
    return this.isRecurring ? this.state.recurrence ?? null : null;
  }

  /** Whether the expense is tax-deductible */
  get isTaxDeductible(): boolean {
    return this.state.isTaxDeductible;
  }

  /** Returns the schedule for one-time expenses, empty array if none */
  get schedule(): { month: YYYYMM; amount: MajikMoney }[] {
    return this.state.schedule || [];
  }

  /** Amount of the expense */
  get amount(): MajikMoney {
    return this.state.amount;
  }

  get depreciationMonths(): number | undefined {
    return this.state.capitalMeta?.depreciationMonths;
  }

  /** True if this expense is recurring */
  get isRecurring(): boolean {
    return (
      this.type === ExpenseType.Operating &&
      !!this.state.schedule &&
      this.state.schedule.length > 1
    );
  }

  /** True if this expense is a one-time expense */
  get isOneTime(): boolean {
    return (
      this.type === ExpenseType.Operating &&
      !!this.state.schedule &&
      this.state.schedule.length === 1
    );
  }

  /** True if this expense is a capital/depreciable expense */
  get isCapital(): boolean {
    return this.type === ExpenseType.Capital;
  }

  /* ---------- Core Behavior ---------- */

  /**
   * Calculate cash outflow for a given month.
   * For scheduled one-time expenses, sums matching schedule entries.
   * For recurring expenses, returns the full amount if recurrence matches.
   * @param month YYYYMM format
   * @returns MajikMoney
   */
  cashOutForMonth(month: YYYYMM): MajikMoney {
    if (this.state.schedule) {
      return this.state.schedule
        .filter((s) => s.month === month)
        .reduce(
          (sum, s) => sum.add(s.amount),
          MajikMoney.zero(this.state.amount.currency.code)
        );
    }

    return MajikMoney.zero(this.state.amount.currency.code);
  }

  /**
   * Returns the accounting expense for a given month.
   * Includes depreciation for capital expenses.
   * @param month YYYYMM format
   * @returns MajikMoney
   */
  expenseForMonth(month: YYYYMM): MajikMoney {
    if (!this.isCapital) {
      return this.cashOutForMonth(month);
    }

    const meta = this.state.capitalMeta!;
    const start = this.capitalStartMonth;
    const elapsed = this.monthDiffInclusive(start, month);

    if (elapsed <= 0) {
      return MajikMoney.zero(this.amount.currency.code);
    }

    if (elapsed > meta.depreciationMonths!) {
      return MajikMoney.zero(this.amount.currency.code);
    }

    return this.depreciationPerMonth();
  }

  private depreciationPerMonth(): MajikMoney {
    const { depreciationMonths, residualValue } = this.state.capitalMeta!;

    const base = residualValue
      ? this.amount.subtract(residualValue)
      : this.amount;

    return base.divide(depreciationMonths!);
  }

  /**
   * Get the net book value of this capital expense up to a specific month.
   * NBV = Cost - Accumulated Depreciation (straight-line).
   *
   * @param month - Month in YYYY-MM format.
   * @returns Remaining book value as MajikMoney.
   */
  getNetBookValueUpTo(month: YYYYMM): MajikMoney {
    if (!this.isCapital) {
      return MajikMoney.zero(this.amount.currency.code);
    }

    if (!isValidYYYYMM(month)) {
      throw new Error("Invalid month");
    }

    const depreciationMonths = this.state.capitalMeta?.depreciationMonths ?? 0;
    const residual =
      this.state.capitalMeta?.residualValue ??
      MajikMoney.zero(this.amount.currency.code);

    // Determine start month: use first month in schedule if exists, else current month
    const startMonth = this.capitalStartMonth;

    const monthsElapsed = this.monthDiffInclusive(startMonth, month);

    if (monthsElapsed <= 0) {
      return this.amount;
    }

    if (monthsElapsed >= depreciationMonths) {
      return residual;
    }

    // Straight-line depreciation using MajikMoney arithmetic
    const depreciable = this.amount.subtract(residual);
    const perMonth = depreciable.divide(depreciationMonths);
    const accumulated = perMonth.multiply(monthsElapsed);

    return this.amount.subtract(accumulated).greaterThan(residual)
      ? this.amount.subtract(accumulated)
      : residual;
  }

  /* ---------- Updaters (Immutable) ---------- */

  /**
   * Returns a new Expense instance with updated amount
   * @param amount New MajikMoney amount
   * @returns Expense
   */
  withAmount(amount: MajikMoney): Expense {
    return Expense.create({ ...this.state, amount });
  }

  /**
   * Returns a new Expense instance with updated name
   * @param name New name
   * @returns Expense
   */
  rename(name: string): Expense {
    return Expense.create({ ...this.state, name });
  }

  /**
   * Returns a new Expense instance with updated period range
   * @param period New period range
   * @returns Expense
   */
  updatePeriod(period: PeriodYYYYMM): Expense {
    if (!period || !period?.startMonth || !period?.endMonth) {
      throw new Error("Recurring expense must define period");
    }

    if (monthsInPeriod(period.startMonth, period.endMonth) <= 0) {
      throw new Error("Invalid expense period");
    }

    let schedule = this.state.schedule;

    if (this.isRecurring) {
      schedule = Expense.generateExpenseScheduleForPeriod(
        monthsInPeriod(period.startMonth, period.endMonth),
        this.state.amount,
        this.state.recurrence || Recurrence.Monthly,
        period.startMonth
      );
    }

    return Expense.create({ ...this.state, schedule });
  }

  /**
   * Purchase or anchor month of the expense.
   * - One-time: expense month
   * - Capital: purchase month
   * - Recurring: first scheduled month
   */
  get purchaseMonth(): YYYYMM | null {
    if (!this.schedule?.length) return null;
    return this.schedule[0].month;
  }

  /* ---------- Helpers ---------- */

  /** Helper: inclusive month difference (e.g., Janâ†’Mar = 3) */
  private monthDiffInclusive(start: YYYYMM, end: YYYYMM): number {
    const [sy, sm] = start.split("-").map(Number);
    const [ey, em] = end.split("-").map(Number);
    return (ey - sy) * 12 + (em - sm) + 1;
  }

  /** Validate internal state */
  private validate(): void {
    if (!this.state.amount) {
      throw new Error("Expense must define an amount");
    }
    if (this.state.amount.isNegative()) {
      throw new Error("Expense amount cannot be negative");
    }
    if (this.type === ExpenseType.Capital) {
      if (!this.state.capitalMeta?.depreciationMonths) {
        throw new Error("Capital expense must define depreciationMonths");
      }

      if (!this.state.schedule || this.state.schedule.length !== 1) {
        throw new Error(
          "Capital expense must define exactly one purchase month"
        );
      }
    }

    this.validateCurrencyConsistency();
  }

  private get capitalStartMonth(): YYYYMM {
    if (!this.isCapital || !this.state.schedule?.length) {
      throw new Error("Capital expense has no start month");
    }
    return this.state.schedule[0].month;
  }

  /** Ensure all scheduled amounts match expense currency */
  private validateCurrencyConsistency(): void {
    if (this.state.schedule) {
      for (const s of this.state.schedule) {
        if (s.amount.currency.code !== this.state.amount.currency.code) {
          throw new Error("All schedule amounts must match expense currency");
        }
      }
    }
  }

  /** Normalize state before creating an Expense */
  private static normalize(state: ExpenseState): ExpenseState {
    return {
      ...state,
      recurrence: state.recurrence,
      capitalMeta:
        state.type === ExpenseType.Capital
          ? {
              residualValue: MajikMoney.zero(state.amount.currency.code),
              ...state.capitalMeta,
            }
          : undefined,
    };
  }

  /* ---------- Serialization ---------- */

  /**
   * Converts the current Expense object to a plain JavaScript object (JSON).
   * @returns {ExpenseJSON} - The plain object representation of the Expense instance.
   */
  toJSON(): ExpenseJSON {
    const preJSON: ExpenseJSON = {
      ...this.state,
    };

    const serializedMoney: ExpenseJSON = serializeMoney(preJSON);

    return serializedMoney;
  }

  /**
   * Parse an Expense from a JSON object (produced by `toJSON`).
   * @param json JSON object
   * @returns Expense instance
   */
  static parseFromJSON(json: string | ExpenseJSON): Expense {
    // If the input is a string, parse it as JSON

    const rawObject: ExpenseJSON =
      typeof json === "string"
        ? JSON.parse(json)
        : structuredClone
        ? structuredClone(json)
        : JSON.parse(JSON.stringify(json));

    const parsedData: ExpenseState = deserializeMoney(rawObject);

    return Expense.create(parsedData);
  }
}
